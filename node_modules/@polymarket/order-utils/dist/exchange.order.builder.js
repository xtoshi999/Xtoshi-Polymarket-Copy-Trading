"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExchangeOrderBuilder = void 0;
const tslib_1 = require("tslib");
const eth_sig_util_1 = require("@metamask/eth-sig-util");
const exchange_order_const_1 = require("./exchange.order.const");
const signature_types_model_1 = require("./model/signature-types.model");
const utils_1 = require("./utils");
class ExchangeOrderBuilder {
    constructor(contractAddress, chainId, signer, generateSalt = utils_1.generateOrderSalt) {
        this.contractAddress = contractAddress;
        this.chainId = chainId;
        this.signer = signer;
        this.generateSalt = generateSalt;
    }
    /**
     * build an order object including the signature.
     * @param orderData
     * @returns a SignedOrder object (order + signature)
     */
    buildSignedOrder(orderData) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = yield this.buildOrder(orderData);
            const orderTypedData = this.buildOrderTypedData(order);
            const orderSignature = yield this.buildOrderSignature(orderTypedData);
            return Object.assign(Object.assign({}, order), { signature: orderSignature });
        });
    }
    /**
     * Creates an Order object from order data.
     * @param OrderData
     * @returns a Order object (not signed)
     */
    buildOrder({ maker, taker, tokenId, makerAmount, takerAmount, side, feeRateBps, nonce, signer, expiration, signatureType, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof signer == 'undefined' || !signer) {
                signer = maker;
            }
            const signerAddress = yield this.signer.getAddress();
            if (signer !== signerAddress) {
                throw new Error('signer does not match');
            }
            if (typeof expiration == 'undefined' || !expiration) {
                expiration = '0';
            }
            if (typeof signatureType == 'undefined' || !signatureType) {
                // Default to EOA 712 sig type
                signatureType = signature_types_model_1.SignatureType.EOA;
            }
            return {
                salt: this.generateSalt(),
                maker,
                signer,
                taker,
                tokenId,
                makerAmount,
                takerAmount,
                expiration,
                nonce,
                feeRateBps,
                side,
                signatureType,
            };
        });
    }
    /**
     * Parses an Order object to EIP712 typed data
     * @param order
     * @returns a EIP712TypedData object
     */
    buildOrderTypedData(order) {
        return {
            primaryType: 'Order',
            types: {
                EIP712Domain: exchange_order_const_1.EIP712_DOMAIN,
                Order: exchange_order_const_1.ORDER_STRUCTURE,
            },
            domain: {
                name: exchange_order_const_1.PROTOCOL_NAME,
                version: exchange_order_const_1.PROTOCOL_VERSION,
                chainId: this.chainId,
                verifyingContract: this.contractAddress,
            },
            message: {
                salt: order.salt,
                maker: order.maker,
                signer: order.signer,
                taker: order.taker,
                tokenId: order.tokenId,
                makerAmount: order.makerAmount,
                takerAmount: order.takerAmount,
                expiration: order.expiration,
                nonce: order.nonce,
                feeRateBps: order.feeRateBps,
                side: order.side,
                signatureType: order.signatureType,
            },
        };
    }
    /**
     * Generates order's signature from a EIP712TypedData object + the signer address
     * @param typedData
     * @returns a OrderSignature that is an string
     */
    buildOrderSignature(typedData) {
        delete typedData.types.EIP712Domain;
        return this.signer._signTypedData(typedData.domain, typedData.types, typedData.message);
    }
    /**
     * Generates the hash of the order from a EIP712TypedData object.
     * @param orderTypedData
     * @returns a OrderHash that is an string
     */
    buildOrderHash(orderTypedData) {
        const message = orderTypedData;
        return (exchange_order_const_1.ZX +
            eth_sig_util_1.TypedDataUtils.eip712Hash(message, eth_sig_util_1.SignTypedDataVersion.V4).toString('hex'));
    }
}
exports.ExchangeOrderBuilder = ExchangeOrderBuilder;
//# sourceMappingURL=exchange.order.builder.js.map